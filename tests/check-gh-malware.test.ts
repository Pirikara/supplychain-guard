import { execSync } from 'node:child_process';
import { writeFileSync, mkdirSync, rmSync, existsSync } from 'node:fs';
import { join } from 'node:path';

// Mock fetch for testing
const mockFetch = jest.fn();
const originalFetch = global.fetch;

describe('check-gh-malware', () => {
  const testDir = join(__dirname, 'gh-malware-test');
  const testChangedFile = join(testDir, 'changed.json');
  const originalCwd = process.cwd();

  beforeAll(() => {
    try {
      rmSync(testDir, { recursive: true, force: true });
    } catch {}
    mkdirSync(testDir, { recursive: true });

    // Mock fetch globally for all tests
    global.fetch = mockFetch;
  });

  afterAll(() => {
    try {
      rmSync(testDir, { recursive: true, force: true });
    } catch {}

    // Restore original fetch
    global.fetch = originalFetch;
  });

  beforeEach(() => {
    process.chdir(testDir);

    // Reset mock before each test and setup default successful response
    mockFetch.mockReset();
    mockFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve([]) // Empty advisories by default
    });
  });

  afterEach(() => {
    process.chdir(originalCwd);
  });

  describe('basic functionality', () => {
    it('should handle missing changed.json file', () => {
      if (existsSync(testChangedFile)) {
        rmSync(testChangedFile);
      }

      try {
        execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json false`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'fake-token' }
        });
        fail('Expected script to exit with error');
      } catch (error: any) {
        expect(error.status).toBe(1);
        expect(error.stderr).toContain('changed.json file not found');
      }
    });

    it('should require GITHUB_TOKEN', () => {
      const testData = [{ name: 'test-package', version: '1.0.0' }];
      writeFileSync(testChangedFile, JSON.stringify(testData, null, 2));

      try {
        execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json false`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: undefined }
        });
        fail('Expected script to exit with error');
      } catch (error: any) {
        expect(error.status).toBe(1);
        expect(error.stderr).toContain('GITHUB_TOKEN is required');
      }
    });

    it('should handle empty changed.json array', () => {
      writeFileSync(testChangedFile, '[]');

      try {
        execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json false`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'fake-token' }
        });
        // Should succeed with no output for empty array
      } catch (error: any) {
        // If it fails due to API call, that's expected in test environment
        expect(error.stderr || '').not.toContain('changed.json file not found');
      }
    });

    it('should handle invalid JSON gracefully', () => {
      writeFileSync(testChangedFile, 'invalid json');

      try {
        execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json false`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'fake-token' }
        });
        fail('Expected script to fail on invalid JSON');
      } catch (error: any) {
        expect(error.status || error.code).toBeDefined();
        expect(error.stderr || '').toContain('Error during malware check');
      }
    });

    it('should handle network errors gracefully in warn-only mode', () => {
      const testData = [{ name: 'test-package', version: '1.0.0' }];
      writeFileSync(testChangedFile, JSON.stringify(testData, null, 2));

      try {
        execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json true`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'invalid-token' }
        });
        // In warn-only mode, should continue even with API errors
      } catch (error: any) {
        // Should show error but not exit with code 1 in warn-only mode
        if (error.status === 1) {
          // If it still exits with 1, check that it's a network error being handled
          expect(error.stderr).toContain('Error during malware check');
        }
      }
    });
  });

  describe('version handling', () => {
    it('should handle various version formats', () => {
      const testData = [
        { name: 'package-a', version: '1.0.0' },
        { name: 'package-b', version: '^2.1.0' },
        { name: 'package-c', version: '~3.0.1' },
        { name: 'package-d', version: 'invalid-version' }
      ];
      writeFileSync(testChangedFile, JSON.stringify(testData, null, 2));

      try {
        execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json true`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'fake-token' },
          timeout: 10000
        });
      } catch (error: any) {
        // Expected to fail due to API call, but should handle version parsing
        expect(error.stderr || '').not.toContain('version');
      }
    });
  });

  describe('output format', () => {
    it('should provide informative output messages', () => {
      const testData = [{ name: 'express', version: '4.18.0' }];
      writeFileSync(testChangedFile, JSON.stringify(testData, null, 2));

      try {
        const result = execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json true`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'fake-token' },
          timeout: 10000
        });

        // Should show progress messages for individual package searches
        expect(result).toContain('Checking');
        expect(result).toContain('changed packages');
      } catch (error: any) {
        // Even if API fails, should show progress messages
        const output = error.stdout || error.stderr || '';
        expect(output).toMatch(/Checking|Searching malware advisories for/);
      }
    });

    it('should show individual package search progress', () => {
      const testData = [
        { name: 'express', version: '4.18.0' },
        { name: 'lodash', version: '4.17.21' }
      ];
      writeFileSync(testChangedFile, JSON.stringify(testData, null, 2));

      try {
        const result = execSync(`node ${join(__dirname, '../dist/check-gh-malware.js')} changed.json true`, {
          encoding: 'utf8',
          stdio: 'pipe',
          env: { ...process.env, GITHUB_TOKEN: 'fake-token' },
          timeout: 15000
        });

        // Should show individual package search messages
        expect(result).toContain('Searching for malware advisories for 2 specific packages');
      } catch (error: any) {
        // Even if API fails, should show package-specific search messages
        const output = error.stdout || error.stderr || '';
        expect(output).toMatch(/Searching malware advisories for|specific packages/);
      }
    });
  });
});