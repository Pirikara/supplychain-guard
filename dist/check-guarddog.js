"use strict";var h=require("child_process"),a=require("fs"),k={npm:"npm",pip:"pypi",go:"go",actions:"github-action"};function $(n,i){return!!(i==="npm"&&n.startsWith("@types/"))}function b(n){let i=[];return n==="pypi"&&i.push("repository_integrity_mismatch"),i.map(l=>`--exclude-rules ${l}`).join(" ")}async function j(n,i,l){try{console.log(`  Scanning ${n}:${i}@${l}...`);let g=b(n),d=`python3 -m guarddog "${n}" scan "${i}" --version "${l}" ${g} --output-format json`,r=(0,h.execSync)(d,{encoding:"utf8",stdio:"pipe"});if(!r.trim())return null;let p=JSON.parse(r);return p.ecosystem=n,p}catch{return null}}async function D(){try{return console.log("Installing GuardDog..."),process.env.NODE_ENV==="test"?(console.log("Test environment detected, skipping GuardDog installation"),!1):((0,h.execSync)("python3 -m pip install --quiet guarddog",{stdio:"inherit"}),!0)}catch{return console.warn("Failed to install GuardDog via pip, skipping scan"),!1}}async function O(){let n=process.argv[2]||"changed.json",i=(process.argv[3]||"false")==="true";(0,a.existsSync)(n)||(console.error(`Error: ${n} file not found`),process.exit(1));let l=JSON.parse((0,a.readFileSync)(n,"utf8"));if(l.length===0){console.log("No changed packages -> skip guarddog"),(0,a.writeFileSync)("guarddog.json","[]");return}if(!await D()){(0,a.writeFileSync)("guarddog.json","[]");return}let g={},d=new Set;for(let s of l){let o=k[s.ecosystem];if(!o){d.add(s.ecosystem);continue}$(s.name,s.ecosystem)||(g[o]||(g[o]=[]),g[o].push({name:s.name,version:s.version}))}let r=[],p=8,f=[];for(let[s,o]of Object.entries(g))for(let e of o)f.push({ecosystem:s,name:e.name,version:e.version});if(d.size>0&&console.log(`Skipping unsupported ecosystems: ${Array.from(d).join(", ")}`),f.length===0){console.log("No packages to scan with GuardDog"),(0,a.writeFileSync)("guarddog.json","[]");return}console.log(`Scanning ${f.length} packages across all ecosystems (concurrency: ${p})...`);let m=p;for(let s=0;s<f.length;s+=m){let o=f.slice(s,s+m),e=Math.floor(s/m)+1,c=Math.ceil(f.length/m);console.log(`Processing batch ${e}/${c} (${o.length} packages)...`);let u=o.map(y=>j(y.ecosystem,y.name,y.version)),t=await Promise.all(u);r.push(...t.filter(y=>y!==null))}if((0,a.writeFileSync)("guarddog.json",JSON.stringify(r,null,2)),r.length>0){console.log(`GuardDog findings: ${r.length}`);let s={};for(let e of r)e.ecosystem&&(s[e.ecosystem]=(s[e.ecosystem]||0)+1);for(let[e,c]of Object.entries(s))console.log(`  ${e}: ${c} findings`);let o=r.filter(e=>e.errors&&Object.keys(e.errors).length>0?!0:e.results&&Object.keys(e.results).length>0?Object.entries(e.results).filter(([u,t])=>!(t==null||typeof t=="object"&&Object.keys(t).length===0||Array.isArray(t)&&t.length===0)).length>0:!1);if(o.length>0){console.log(`
Detailed findings (${o.length} packages with actual issues):`);for(let e of o){if(console.log(`
Package: ${e.package}`),e.ecosystem&&console.log(`  Ecosystem: ${e.ecosystem}`),e.errors&&Object.keys(e.errors).length>0){console.log("  Issues found:");for(let[c,u]of Object.entries(e.errors))console.log(`    - ${c}: ${u}`)}if(e.results&&Object.keys(e.results).length>0){let c=Object.entries(e.results).filter(([u,t])=>!(t==null||typeof t=="object"&&Object.keys(t).length===0||Array.isArray(t)&&t.length===0));if(c.length>0){console.log("  Additional findings:");for(let[u,t]of c)console.log(`    - ${u}: ${JSON.stringify(t)}`)}}}}else console.log(`
No packages with actual security issues found.`);i&&(console.error(`GuardDog reported ${r.length} findings across all ecosystems`),process.exit(1))}else console.log("GuardDog produced no findings.")}O().catch(n=>{console.error(`GuardDog scan failed: ${n instanceof Error?n.message:n}`),process.exit(1)});
