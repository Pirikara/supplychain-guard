import { readFileSync, existsSync } from "node:fs";
import * as semver from "semver";

type Changed = { name: string; version: string }[];

const token = process.env.GITHUB_TOKEN;
if (!token) {
  console.error("GITHUB_TOKEN is required");
  process.exit(1);
}

async function fetchJSON(path: string) {
  const res = await fetch(`https://api.github.com${path}`, {
    headers: {
      "User-Agent": "supplychain-guard",
      "Authorization": `Bearer ${token}`,
      "Accept": "application/vnd.github+json"
    }
  });
  if (!res.ok) throw new Error(`GitHub API ${res.status}`);
  return res.json();
}

async function getMalwareAdvisoriesForPackages(packages: Changed) {
  const index = new Map<string, string[]>(); // name -> ranges[]

  console.log(`Searching for malware advisories for ${packages.length} specific packages...`);

  for (const { name } of packages) {
    console.log(`Searching malware advisories for ${name}...`);

    try {
      // Search for advisories affecting this specific package
      const advisories = await fetchJSON(`/advisories?type=malware&ecosystem=npm&affects=${encodeURIComponent(name)}&per_page=100`);

      if (Array.isArray(advisories) && advisories.length > 0) {
        console.log(`Found ${advisories.length} malware advisories for ${name}`);

        for (const adv of advisories) {
          for (const v of adv?.vulnerabilities ?? []) {
            const pkgName = v?.package?.name;
            const range = v?.vulnerable_version_range;
            if (pkgName === name && range) {
              const arr = index.get(name) ?? [];
              arr.push(range);
              index.set(name, arr);
            }
          }
        }
      } else {
        console.log(`No malware advisories found for ${name}`);
      }
    } catch (error) {
      console.warn(`Failed to search advisories for ${name}: ${error instanceof Error ? error.message : error}`);
    }
  }

  console.log(`Retrieved malware advisories for ${index.size} packages`);
  return index;
}

(async function main() {
  const file = process.argv[2];
  const warnOnly = String(process.argv[3] || "false") === "true"; // malwareは基本Fail

  if (!existsSync(file)) {
    console.error(`Error: changed.json file not found: ${file}`);
    process.exit(1);
  }

  try {
    const changed: Changed = JSON.parse(readFileSync(file, "utf8"));
    console.log(`Checking ${changed.length} changed packages against GitHub malware advisories...`);

    const idx = await getMalwareAdvisoriesForPackages(changed);

    const hits: { name: string; version: string }[] = [];
    for (const { name, version } of changed) {
      const ranges = idx.get(name) || [];
      const v = semver.coerce(version);
      if (!v) continue;
      if (ranges.some(r => {
        try { return semver.satisfies(v, r, { includePrerelease: true }); } catch { return false; }
      })) hits.push({ name, version });
    }

    if (hits.length) {
      const msg = "Malware advisory hit:\n" + hits.map(h => `- ${h.name}@${h.version}`).join("\n");
      if (warnOnly) console.warn(msg);
      else { console.error(msg); process.exit(1); }
    } else {
      console.log("No malware detected in changed dependencies");
    }
  } catch (error) {
    console.error(`Error during malware check: ${error instanceof Error ? error.message : error}`);
    if (warnOnly) {
      console.warn("Malware check failed, but continuing due to warn-only mode");
    } else {
      process.exit(1);
    }
  }
})();
